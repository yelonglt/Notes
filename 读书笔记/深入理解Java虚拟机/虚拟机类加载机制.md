###虚拟机类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

####类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）、卸载（Unloading）。其中验证、准备和解析三个部分统称为链接（Linking）。

* 类的加载过程必须按照这种顺序按部就班地（通常这些阶段都是互相交叉混合式进行的）开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。
* 虚拟机规范中规定在下列五种情况必须立即对类进行初始化
  1. 遇到new（new对象）、getstatic（获取类静态变量）、putstatic（设置类静态变量）或invokestatic（调用类静态方法）这4条字节码指令时，如果这个类没有初始化，则需要先触发其初始化。
  2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
  3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。
  4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个主类。
  5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic、REF_putstatic、REF_invokestatic的方法句柄，并且这个方法句柄所对应的类没有初始化，则需要先触发器初始化。

####类加载的过程

* 加载：在加载阶段虚拟机需要做三件事
  1. 通过一个类的全限定名来获取定义此类的二进制字节流
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
  
* 验证：验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。如果验证到的字节流不符合Class文件格式的约束，虚拟机就回抛出一个java.lang.VerifyError异常或其子类异常。验证完成4个阶段的校验动作
 1. 文件格式验证。验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。该阶段主要是基于二进制字节流验证。
 2. 元数据验证。对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。该阶段主要是基于方法区的存储结构验证。
 3. 字节码验证。主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
 4. 符号引用验证。这个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。目的是为了保证解析动作能正产执行，如果无法通过符号引用验证将会抛出java.lang.IncompatibleClassChangeError异常的子类，如IllegalAccessError、NoSuchFieldError、NoSuchMethodError。

* 准备：准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，这写变量所使用的内存都将在方法区进行分配。这时候进行分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

* 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
  1. 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
  2. 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

* 初始化：到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。初始化阶段是执行类构造器\<clinit>() 方法的过程。
 1. \<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是有语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
 2. \<clinit>()方法与类的构造函数（实例构造器\<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在父类的\<clinit>()方法最先执行完毕。
 3. 由于父类的\<clinit>()方法先执行，也就是意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
 4. \<clinit>()方法对于类和接口来说不是必须的，如果一个类中没有静态语句块，也就没有对变量的赋值操作，那么编译器可以不为这个类生成\<clinit>()方法
 5. 在多线程环境，虚拟机会保证只有一个线程去执行这个类的\<clinit>()方法