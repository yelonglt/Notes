###运行时数据区域

1. 程序计数器。线程私有
2. Java虚拟机栈。线程私有
3. 本地方法栈。线程私有
4. Java堆。线程共享
5. 方法区。线程共享

####程序计数器（Program Counter Register）
* 程序计数器是一块很小的内存空间，它可以看作是当前线程所执行的字节码的行号计数器。
* 由于Java虚拟机是通过线程轮流并分配处理器的执行时间的方式来实现的。所以在任何一个时刻，一个处理器（对于多核处理器来说就是一个内核）都会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。

####Java虚拟机栈（Java Virtual Method Stack）
* Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

####本地方法栈（Native Method Stack）
* 本地方法栈和Java虚拟机栈类似。Java虚拟机栈执行的是Java方法服务；本地方法栈执行的是Native方法服务。

####Java堆（Java Heap）
* Java堆是Java虚拟机所管理内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
* Java堆是垃圾收集器管理的主要区域，因此很多时候被称为GC堆（Garbage Collected Heap）。
* 堆大小可以通过参数-Xms（初始堆大小）、-Xmx（最大堆大小）指定。
* 从内存回收的角度，Java堆细分为新生代和老年代（新生代和老年代的比例为1:2，可以通过参数-XX:NewRatio=N指定1:N）。在细致一点新生代分为Eden空间（占新生代8/10）、From Survivor空间（占新生代1/10）、To Survivor空间（占新生代1/10）。

####方法区（Method Area）
* 方法区也是各个线程共享的区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译的代码等数据。
* 运行时常量池（Runtime Constant Pool）也是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。

####常见虚拟机异常
* StackOverflowError异常。如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。
* OutOfMemoryError异常。如果虚拟机无法申请足够的内存，将会抛出此异常。也就是俗称的内存溢出。

####对象的创建
* 指针碰撞（Bump the Pointer）。假如堆中的内存是绝对规整的，所用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界点指示器。那分配内存只需要移动一段与对象同样大小相对的距离，这种分配方式称为指针碰撞。
* 空闲列表（Free List）。假如堆中的内存不规整，已使用的内存和空闲的内存相互交错，那么虚拟机必须维护一个列表，记录那些内存块是可用的，在分配内存的时候找到一块足够大的内存空间划分给内存实例，并更新列表上的记录，这种分配方式称为空间列表。
* 使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞；使用CMS这种基于标记清除（Mark-Sweep）算法的收集器时，系统采用的分配算法是空闲列表。

####对象的内存布局
对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

* 对象头分为两个部分。第一部分用于存储对象自身的运行数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据长度为在32位虚拟机和64位虚拟机的长度分别为32bit和64bit。第二个部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
* 实例数据，就是对象真正存储的有效信息，也就是程序代码中所定义的各种类型的字段内容。
* 对齐填充，这个不是必然存在的，仅起到占位符的作用。虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，就是对象的大小必须是8字节的整数倍。

####对象的访问定位
建立对象是为了使用对象，我们的Java程序需要通过栈上的refreence数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只指定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆总中的对象的具体位置，所以访问对象的方式取决于虚拟机的实现。目前主流的访问方式有使用句柄和直接指针。

* 句柄访问。Java堆中将划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含对象实例数据和类型数据各自的具体地址信息。所以需要两次定位
* 直接指针访问，reference中存储的直接就是对象地址。
* 两种方式优缺点分析
  1. 使用句柄访问的最大好处就是reference中存储的是句柄地址，在对象被移动（垃圾收集器移动对象是非常普遍现象）时，只会改变句柄中的实例数据指针，而reference本身不需要修改。
  2. 使用直接访问的最大好处就是速度更快，节省一次指针定位的开销。由于对象的访问在Java中非常的频繁，这类开销积少成多是一项非常可观的执行。
  