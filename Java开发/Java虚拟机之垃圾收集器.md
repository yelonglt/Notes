##垃圾收集器

####判断对象是否存活的算法

1. 引用计数算法。给对象添加一个引用计数器，每当有一个地方引用计数器加1，当引用失效计数器减1，任何时候计数器为0的对象就是不能再使用的对象。目前主流的Java虚拟机里面没有选用引用计数算法来管理内存，主要原因是它很难解决对象之间的相互循环引用问题。
2. 可达性分析算法。就是用一个"GC Roots"的对象作为起始点，从这个节点向下搜索所走过的路径称为引用链，当一个对象到"GC Roots"没有引用链，则证明此对象不可用。

####引用
在JDK1.2以前，Java中引用的定义很传统，如果引用类型的数据中存储的数值代表的是另外一块内存的其实地址，就称为这块内存代表着一个引用。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用。

1. 强引用就是指在程序代码之中普遍存在的，类似"Object obj = new  Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
2. 软引用是用来描述一些还有用但并非必须的对象。JDK提供SoftReference类来实现软引用。
3. 弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。JDK提供WeakReference类来实现弱引用。
4. 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。为一个对象设置虚引用关系的唯一目的是在这个对象被收集器回收时收到一个系统通知。JDK提供PhantomReference类来实现虚引用。

####垃圾收集算法

1. 标记-清除算法（Mark-Sweep）。首先标记所有需要回收的对象，在标记完成之后统一回收所有标记的对象。两个不足：一个是效率问题，标记和清除两个过程效率并不高；另一个是空间问题，标记被清除之后会产生大量不连续的内存碎片。
2. 复制算法（Copying）。将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，然后将已使用过的内存空间一次清理掉。复制手机算法在对象的存活率较高的情况下进行较多的复制操作，效率将会变低。
3. 标记-整理算法（Mrak-Compact）。标记过程和标记清除算法一样，但是后续不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后清理掉端边界以外的内存。
4. 分代收集算法（Generational-Collection）。一般将Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的手机算法。

####垃圾收集器

1. Serial收集器。
2. ParNew收集器。
3. Parallel Scavenge收集器。
4. Serial Old收集器。
5. Parallel Old收集器。
6. CMS收集器。
7. G1收集器。

收集器1-6采用的堆结构是新生代（默认1/3堆内存大小）和老年代（默认2/3堆内存大小）；G1收集器也是分区回收。跨区访问是通过每个区都有一个Remembered Set，虚拟机使用Remembered Set来避免全堆扫描。
